#!/bin/bash
# build.sh - Enhanced build script with optimized VDF verification
set -euo pipefail

# Colors for better output
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Function to print colored output
print_status() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Function to check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Validate environment
print_status "üîç Validating build environment..."

# Check Node.js version
if ! command_exists node; then
    print_error "Node.js not found. Please install Node.js 16+"
    exit 1
fi

NODE_VERSION=$(node --version | cut -d'v' -f2 | cut -d'.' -f1)
if [ "$NODE_VERSION" -lt 16 ]; then
    print_error "Node.js 16+ required, found: $(node --version)"
    exit 1
fi

print_success "Node.js $(node --version) detected"

# Check Rust
if ! command_exists cargo; then
    print_error "Rust/Cargo not found. Please install Rust"
    exit 1
fi

print_success "Rust $(rustc --version | cut -d' ' -f2) detected"

# Check WebAssembly target
if ! rustup target list --installed | grep -q "wasm32-unknown-emscripten"; then
    print_error "WebAssembly target not installed. Run: rustup target add wasm32-unknown-emscripten"
    exit 1
fi

print_success "WebAssembly target available"

print_status "üõ†Ô∏è  Setting up Emscripten environment..."

# Prefer local emsdk directory if available, otherwise fallback to ~/tools/emsdk
if [ -f ./emsdk/emsdk_env.sh ]; then
    source ./emsdk/emsdk_env.sh
    print_success "Using local Emscripten SDK"
elif [ -f ~/tools/emsdk/emsdk_env.sh ]; then
    source ~/tools/emsdk/emsdk_env.sh
    print_success "Using Emscripten SDK from ~/tools/emsdk"
else
    print_error "Emscripten SDK not found in ./emsdk/ or ~/tools/emsdk/"
    print_error "Please install Emscripten SDK as documented in README.md"
    exit 1
fi

# Verify emcc is available
if ! command_exists emcc; then
    print_error "emcc not found. Emscripten SDK not properly activated"
    exit 1
fi

EMCC_VERSION=$(emcc --version | head -n1)
print_success "Emscripten ready: $EMCC_VERSION"

print_status "üßπ Cleaning previous builds..."
cargo clean
rm -rf dist

# Create necessary directories
print_status "üìÅ Creating project structure..."
mkdir -p src/types
mkdir -p tests
mkdir -p dist

# Create type definitions if they don't exist
if [ ! -f "src/types/global.d.ts" ]; then
    print_status "üìù Creating type definitions..."
    cat > src/types/global.d.ts << 'EOF'
// Global type declarations to suppress external library errors
declare module 'gmp' {
    const gmp: any;
    export = gmp;
}

declare module '*/vdf.js' {
    const vdfFactory: (options?: any) => Promise<any>;
    export = vdfFactory;
}

declare global {
    interface TextEncoder {
        encode(input?: string): Uint8Array;
    }
    
    interface TextDecoder {
        decode(input?: ArrayBuffer | ArrayBufferView): string;
    }
    
    const TextEncoder: {
        prototype: TextEncoder;
        new(): TextEncoder;
    } | undefined;
    
    const TextDecoder: {
        prototype: TextDecoder;
        new(encoding?: string): TextDecoder;
    } | undefined;
}
EOF
fi

print_status "ü¶Ä Building optimized WebAssembly with fast verification..."
if ! cargo build --target wasm32-unknown-emscripten --release; then
    print_error "WebAssembly build failed"
    exit 1
fi

print_success "WebAssembly build completed"

print_status "üîß Applying buffer reference fix..."
if [ ! -f src/vdf.js ]; then
    print_error "vdf.js not generated by cargo build"
    exit 1
fi

# Apply the buffer fix
sed -i 's/new as(buffer,pointer,size\/as\.BYTES_PER_ELEMENT)/new as(HEAPU8.buffer,pointer,size\/as.BYTES_PER_ELEMENT)/g' src/vdf.js

# Verify the fix was applied  
if ! grep -q "HEAPU8.buffer" src/vdf.js; then
    print_warning "Buffer reference fix may not have been applied"
else
    print_success "Buffer reference fix applied"
fi

# Additional optimizations for the generated JS
print_status "‚ö° Optimizing generated JavaScript..."

# Add performance improvements to the generated JS
if grep -q "createWasm" src/vdf.js; then
    print_success "WebAssembly loading optimizations detected"
fi

print_status "üìã Linting TypeScript..."
if ! npx tslint --project . --quiet; then
    print_warning "TypeScript linting found issues (continuing build)"
else
    print_success "TypeScript linting passed"
fi

print_status "üì¶ Compiling TypeScript..."
if ! npx tsc; then
    print_error "TypeScript compilation failed"
    exit 1
fi

print_success "TypeScript compilation completed"

print_status "üìÇ Organizing build artifacts..."
mkdir -p dist

# Copy WebAssembly files
print_status "üìã Copying WebAssembly files..."
cp src/vdf.* dist/

# Minify JavaScript for production builds
if [ "${NODE_ENV:-}" = "production" ]; then
    print_status "üóúÔ∏è  Minifying JavaScript for production..."
    if ! npx uglify-es dist/index.js > dist/index.min.js; then
        print_warning "JavaScript minification failed, continuing without minification"
    else
        print_success "JavaScript minified"
    fi
fi

# Create performance test if it doesn't exist
if [ ! -f "dist/performance-test.js" ] && [ -f "dist/index.js" ]; then
    print_status "üèÉ Creating performance test..."
    cat > dist/performance-test.js << 'EOF'
const createVdf = require('./index.js');

async function performanceTest() {
    console.log('üöÄ VDF Performance Test Starting...');
    
    try {
        const vdf = await createVdf();
        console.log('‚úÖ VDF library loaded');

        const challenge = Buffer.from('performance_test_challenge_12345');
        const iterations = 5000;
        const intSizeBits = 2048;
        const isPietrzak = false;

        console.log(`üìä Test: ${iterations} iterations, ${intSizeBits} bits, ${isPietrzak ? 'Pietrzak' : 'Wesolowski'}`);

        // Generate proof
        console.log('‚è≥ Generating proof...');
        const startGenerate = Date.now();
        const proof = vdf.generate(iterations, challenge, intSizeBits, isPietrzak);
        const generateTime = Date.now() - startGenerate;
        console.log(`‚úÖ Generated in ${generateTime}ms (${proof.length} bytes)`);

        // Fast verification
        console.log('‚ö° Testing FAST verification...');
        const startFast = Date.now();
        const fastValid = vdf.verify(iterations, challenge, proof, intSizeBits, isPietrzak);
        const fastTime = Date.now() - startFast;
        console.log(`‚ö° Fast verify: ${fastValid ? 'VALID' : 'INVALID'} (${fastTime}ms)`);

        // Slow verification (if available)
        if (typeof vdf.verifySlow === 'function') {
            console.log('üêå Testing SLOW verification...');
            const startSlow = Date.now();
            const slowValid = vdf.verifySlow(iterations, challenge, proof, intSizeBits, isPietrzak);
            const slowTime = Date.now() - startSlow;
            console.log(`üêå Slow verify: ${slowValid ? 'VALID' : 'INVALID'} (${slowTime}ms)`);
            
            const speedup = slowTime > 0 ? (slowTime / fastTime).toFixed(1) : 'N/A';
            console.log(`üéØ Speedup: ${speedup}x faster`);
        }

        const efficiency = ((fastTime / generateTime) * 100).toFixed(1);
        console.log(`üìà Verification efficiency: ${efficiency}% of generation time`);
        console.log('üéâ Performance test completed successfully!');

    } catch (error) {
        console.error('üí• Performance test failed:', error);
        process.exit(1);
    }
}

if (require.main === module) {
    performanceTest();
}

module.exports = { performanceTest };
EOF
fi

# Verify build outputs
print_status "üîç Verifying build outputs..."
REQUIRED_FILES=("dist/index.js" "dist/index.d.ts" "dist/vdf.js" "dist/vdf.wasm")

for file in "${REQUIRED_FILES[@]}"; do
    if [ ! -f "$file" ]; then
        print_error "Required file missing: $file"
        exit 1
    fi
done

print_success "All required build outputs verified"

# Display build summary
print_status "üìä Build Summary:"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "Generated files:"
ls -la dist/ | grep -E '\.(js|wasm|d\.ts)$' || ls -la dist/

# Calculate total size
TOTAL_SIZE=$(du -sh dist/ | cut -f1)
echo "Total build size: $TOTAL_SIZE"

# Show optimization status
if [ -f "dist/index.min.js" ]; then
    ORIGINAL_SIZE=$(stat -f%z dist/index.js 2>/dev/null || stat -c%s dist/index.js)
    MINIFIED_SIZE=$(stat -f%z dist/index.min.js 2>/dev/null || stat -c%s dist/index.min.js)
    SAVINGS=$(echo "scale=1; (1 - $MINIFIED_SIZE / $ORIGINAL_SIZE) * 100" | bc 2>/dev/null || echo "N/A")
    echo "Minification savings: ${SAVINGS}%"
fi

echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

print_success "üéâ Build completed successfully!"
print_status "üß™ Run 'npm test' to verify functionality"
print_status "üèÉ Run 'npm run test:performance' to benchmark performance"

# Quick verification check
print_status "üî¨ Quick verification check..."
if node -e "require('./dist/index.js')().then(() => console.log('‚úÖ Library loads successfully')).catch(e => { console.error('‚ùå Library failed to load:', e.message); process.exit(1); })"; then
    print_success "Library verification passed"
else
    print_error "Library verification failed"
    exit 1
fi